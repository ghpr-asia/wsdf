Thank you for thinking of contributing to wsdf. This document tries to give you
an overview of the codebase. Please supplement this with the documentation on
docs.rs for a fuller understanding.

Before working on wsdf, ensure that Wireshark version 4.0 is installed along
with its header files. On some distros, this may be in a separate
wireshark-devel package.

Some basic understanding of writing dissectors in C would help. See
https://www.wireshark.org/docs/wsdg_html_chunked/ChDissectAdd.html for a
tutorial.

0. Installation notes

Assuming you have the repo cloned, run

	cargo b --all-targets

to ensure that everything builds correctly. It is possible that some problems
arise with libwireshark.so, so please file an issue and we can try to resolve
it.

1. Crates Overview

1.1 epan-sys

The epan-sys crate uses bindgen to produce FFI bindings for some stuff in
Wireshark's epan module. Not all header files are included at the moment -
just the minimum needed for wsdf.

The .h files actually included are listed in wrapper.h. If we need more
types, functions, etc. from Wireshark, we can just add the respective .h
files here.

Note that the epan-sys crate contains a huge bindings.rs file. This file is
pre-generated by bindgen from some wireshark headers. If this crate is built
with the "bindgen" feature turned on, then we will call bindgen at build time to
generate fresh bindings to replace this one. As such, please avoid passing the
--all-features flag when building this crate, since it drastically increases
the build time.

1.2 wsdf-derive

The codegen logic lives here. We have these modules:

    - util: helper functions and types
    - attributes: defines and parses attributes, e.g. #[wsdf(hide)]
    - model: data model for structs and enums
    - crate root: ties everything together

This crate's purpose is to take the input (a struct or enum) and generate the
right code for use in a dissector. To that end, we have two "abstractions" to
help us:

	- StructInnard: a type representing the internals of a struct-like object.
	  This includes structs as well as enum variants.
	- Enum: an enum.

These two types, their methods, along with some helper functions are reponsible
for generating the correct code. A top-down view of this entier codegen process
can be found in lib.rs. Check the proc-macro definition for Dissect (a function
named derive_dissect) and follow along for the big picture.

The actual generated code is pretty simple at a high level:

	- When the plugin is loaded, for each protocol, register the protocol and
	  all its fields.
	- When the dissect routine is invoked, recursively dissect each field.

1.2. wsdf

This is the crate which users are meant to install. It serves three purposes:

    a. Re-exporting epan-sys and wsdf-derive

    b. Defining some traits, most imporantly Dissect and Proto. These traits
	   enable us to dissect things.

	c. Exporting some helpers for our generated code to call.

All the traits are documented, so the easiest way to see what they do is to read
them. This crate implements the traits for basic types like the integers,
Vec<u8>, etc. More impls can be added in the future for other types (e.g. Box<T>
can be interpreted as T for dissection purposes) to make this super generic and
"loose".

3. Tests and examples

cargo test will run all tests.

There are some regular unit tests scattered around. We also use the trybuild
crate (https://docs.rs/trybuild/latest/trybuild/) to test if some kind of
syntax compiles or not. The things to test are found in wsdf/tests/. Some are
meant to compile, while some are meant to fail.

We have some examples in wsdf/examples/. These are also useful for debugging
the generated code via cargo expand.

